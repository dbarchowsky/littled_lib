<?php

namespace Littled\PageContent\SiteSection;


use Littled\App\LittledGlobals;
use Littled\Exception\ConfigurationUndefinedException;
use Littled\Exception\ConnectionException;
use Littled\Exception\ContentValidationException;
use Littled\Exception\NotInitializedException;
use Littled\Exception\RecordNotFoundException;
use Littled\Log\Log;
use Littled\PageContent\Serialized\SerializedContent;
use Littled\Request\IntegerInput;
use Littled\Request\StringSelect;
use Littled\Request\StringTextField;
use Exception;
use Littled\Utility\LittledUtility;

/**
 * Class ContentTemplate
 * @package Littled\Tests\SiteContent
 */
class ContentTemplate extends SerializedContent
{
    /** @var int                Value of this record in the site section table. */
    protected static int        $content_type_id = 33;
    protected static string     $table_name = "content_template";
    protected static string     $local_path_token = 'local';
    /** @var StringTextField    Template name. */
    public StringTextField      $name;
    /** @var IntegerInput       Content type id. */
    public IntegerInput         $content_id;
    /** @var StringTextField    Root directory of the content type, as specified in the parent site_section table. */
    public StringTextField      $template_dir;
    /** @var StringTextField    Relative path to the content template. */
    public StringTextField      $path;
    /** @var StringSelect       Location of the template, e.g. local vs. shared. */
    public StringSelect         $location;
    /** @var StringTextField    Selector for DOM element containing the content generated by this template. */
    public StringTextField      $container_id;
    /** @var StringTextField    Container id wildcard character */
    public StringTextField      $wildcard;
    /** @var IntegerInput       Pointer to $site_section_id property */
    public IntegerInput         $parentID;

    /**
     * ContentTemplate constructor.
     * @param int|null $id ID value of the record. Defaults to NULL.
     * @param int|null $content_type_id Site section id of the record. Defaults to NULL.
     * @param string $name Name of the template. Defaults to empty string.
     * @param string $base_dir Base path where the templates are located. Defaults to empty string.
     * @param string $path Path to the template file. Defaults to empty string.
     * @param string $location Context in which the template is used. Defaults to empty string.
     */
    function __construct(
        ?int $id = null,
        ?int $content_type_id = null,
        string $name = '',
        string $base_dir = '',
        string $path = '',
        string $location = '')
    {
        parent::__construct($id);

        $this->id->label = "Template id";
        $this->id->key = 'templateID';
        $this->id->required = false;
        $this->content_id = new IntegerInput("Content type", "contentTypeID", true, $content_type_id);
        $this->name = new StringTextField("Name", "templateName", true, $name, 45);
        $this->template_dir = new StringTextField("Template directory", "templateDir", false, $base_dir, 200);
        $this->path = new StringTextField("Template file", "templatePath", true, $path, 255);
        $this->location = new StringSelect("Location", "templateLocation", false, $location, 20);
        $this->container_id = new StringTextField("Container", "ctContain", false, '', 50);
        $this->wildcard = new StringTextField("Wildcard", "ctWC", false, '', 8);

        /* non-default column names in database table */
        $this->template_dir->is_database_field = false;
        $this->content_id->column_name = 'site_section_id';

        /* pointer to site section id for the benefit of editing these
         * records in the CMS */
        $this->parentID = &$this->content_id;

        /* ensure this has a trailing slash */
        if ($base_dir) {
            $this->template_dir->setInputValue(rtrim($base_dir, '/') . '/');
        }
    }

    /**
     * @inheritDoc
     */
    public function hasData(): bool
    {
        return ($this->id->value > 0 || $this->path->value || $this->name->value);
    }

    /**
     * Format full path to template file as a convenience, pointing it at
     * either the common directory or local depending on the "location" value.
     * @return string Full path to template file, taking into account if the location
     * is set to the shared location or the local location.
     * @throws Exception
     */
    public function formatFullPath(): string
    {
        $template_dir = '';
        if ($this->path->value) {
            if ($this->template_dir->value) {
                return LittledUtility::joinPaths($this->template_dir->value, $this->path->value);
            }
            switch ($this->location->value) {
                case static::getLocalPathToken():
                    $template_dir = LittledGlobals::getLocalTemplatesPath();
                    break;
                default:
                    $template_dir = LittledGlobals::getSharedTemplatesPath();
                    break;
            }
        }
        return LittledUtility::joinPaths($template_dir, $this->path->value);
    }

    /**
     * @inheritDoc
     */
    public function generateUpdateQuery(): ?array
    {
        return null;
    }

    /**
     * @inheritDoc
     */
    public function getContentLabel(): string
    {
        return 'Content template';
    }

    /**
     * Local path token getter.
     * @return string
     */
    public static function getLocalPathToken(): string
    {
        return static::$local_path_token;
    }

    /**
     * Container id wildcard value getter.
     * @return string
     */
    public function getWildcard(): string
    {
        return $this->wildcard->safeValue();
    }

    /**
     * Insert record id value into container id.
     * @param ?int $record_id
     * @return string
     */
    public function insertRecordIdIntoContainerId(?int $record_id): string
    {
        if (trim(''.$record_id) === '') {
            return $this->container_id->value;
        }
        return str_replace($this->wildcard->value, (string)$record_id, $this->container_id->value);
    }

    /**
     * Retrieves template properties using the object's current content type and operation property values.
     * @return $this
     * @throws ConfigurationUndefinedException
     * @throws NotInitializedException
     * @throws RecordNotFoundException
     */
    public function lookupTemplateProperties(): ContentTemplate
    {
        if (!$this->content_id->hasData() || !$this->name->hasData()) {
            throw new NotInitializedException("Content type and/or operation was not provided.");
        }
        $this->retrieveUsingContentTypeAndOperation();
        return $this;
    }

    /**
     * Looks up and retrieves template properties from the database using section type id and operation name.
     * @param int|null $content_type_id
     * @param ?string $operation
     * @return void
     * @throws ConfigurationUndefinedException
     * @throws RecordNotFoundException
     * @throws Exception
     */
    public function retrieveUsingContentTypeAndOperation(?int $content_type_id = null, ?string $operation = null)
    {
        $content_type_id ??= $this->content_id->value;
        $operation ??= $this->name->value;

        if ($content_type_id === null || $content_type_id < 1) {
            throw new ConfigurationUndefinedException('[' . Log::getShortMethodName() . '] Content type not provided.');
        }
        if (!$operation) {
            throw new ConfigurationUndefinedException('[' . Log::getShortMethodName() . '] Operation not provided.');
        }
        $data = $this->fetchRecords('CALL contentTemplateLookup(?,?)',
            'is',
            $content_type_id,
            $operation);
        if (count($data) < 1) {
            throw new RecordNotFoundException('[' . Log::getShortMethodName() . '] ' . ucfirst($this->name->value) . ' template not found.');
        }
        $this->hydrateFromRecordsetRow($data[0]);
        // stored procedure returned "path" field as "template_path"
        $this->path->setInputValue($data[0]->template_path);
    }

    /**
     * Container id value setter.
     * @param string $id
     * @return $this
     */
    public function setContainerId(string $id): ContentTemplate
    {
        $this->container_id->setInputValue($id);
        return $this;
    }

    /**
     * Content type id value setter.
     * @param int $content_type_id
     * @return $this
     */
    public function setContentType(int $content_type_id): ContentTemplate
    {
        $this->content_id->setInputValue($content_type_id);
        return $this;
    }

    /**
     * Operation value setter.
     * @param string $operation
     * @return $this
     */
    public function setOperation(string $operation): ContentTemplate
    {
        $this->name->setInputValue($operation);
        return $this;
    }

    /**
     * Container id wildcard value setter.
     * @param string $wildcard
     * @return $this
     */
    public function setWildcard(string $wildcard): ContentTemplate
    {
        $this->wildcard->setInputValue($wildcard);
        return $this;
    }

    /**
     * Tests for any existing records in the database that would conflict with the
     * property values of this object instance.
     * @return string Name of content type matching the object's content_type_id property value
     * @throws ConfigurationUndefinedException
     * @throws ConnectionException
     * @throws Exception
     */
    public function testForDuplicateTemplate(): string
    {
        if (null === $this->id->value &&
            0 < $this->content_id->value &&
            $this->name->value) {
            $this->connectToDatabase();
            $query = "CALL contentTemplateSectionNameSelect(?,?)";
            $data = $this->fetchRecords($query, 'is', $this->content_id->value, $this->name->value);
            if (0 < count($data)) {
                return $data[0]->section;
            }
        }
        return '';
    }

    /**
     * Validates the data stored in the instance. Error messages are stored in the instance's $validation_errors
     * property.
     * @param string[] $exclude_properties (Optional) Names of class properties to exclude from validation.
     * @throws ContentValidationException
     * @throws ConfigurationUndefinedException
     * @throws ConnectionException
     * @throws Exception
     */
    public function validateInput(array $exclude_properties = [])
    {
        try {
            parent::validateInput(['parentID']);
        } catch (ContentValidationException $ex) { /* continue */
        }

        if (!$this->template_dir->value && !$this->location->value) {
            $this->addValidationError("Either a template path or location must be specified.");
        }

        if ($section = $this->testForDuplicateTemplate()) {
            $error = "A \"{$this->name->value}\" template already exists for the \"$section\" area of the site.";
            $this->addValidationError($error);
        }

        if ($this->hasValidationErrors()) {
            throw new ContentValidationException("Error validating content templates.");
        }
    }
}